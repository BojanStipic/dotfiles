# vim: set foldmethod=marker foldlevel=0 :

# GENERAL {{{1

snippet include
#include <${1:iostream}>
endsnippet

snippet guard
#ifndef ${1:NAME}_HPP
#define $1_HPP

${VISUAL}$0

#endif /* end of include guard: $1_HPP */
endsnippet

snippet using
using namespace ${1:std};
endsnippet

snippet main
int main()
{
	$0
	return 0;
}
endsnippet

snippet mainn
int main(int argc, char *argv[])
{
	$0
	return 0;
}
endsnippet

# LOOPS {{{1

snippet for
for(int ${1:i} = 0; $1 < ${2:length}; ++$1)
{
	$0
}
endsnippet

snippet fore
for(${3:const ${4:T}&} ${2:element} : ${1:collection})
{
	$0
}
endsnippet

snippet while
while(${1:/* condition */})
{
	$0
}
endsnippet

snippet do
do
{
	$0
} while(${1:/* condition */});
endsnippet

# CLASSES {{{1

snippet namespace
namespace ${1:name}
{
	$0
} ${1/.+/\/* $0 *\//}
endsnippet

snippet class
class ${1:Name}
{
public:
	$0
private:
	$2
};
endsnippet

snippet get
${2:const ${3:T}&} $1() const
{
	return _${1:member};
}
endsnippet

snippet set
void set${1/./\u$0/}(${2:const ${3:T} &}$1)
{
	_${1:member} = $1;
}
endsnippet

snippet getset
${2:const ${3:T}&} $1() const
{
	return _${1:member};
}
void set${1/./\u$0/}(${2/(&)|$/ $1/}$1)
{
	_$1 = $1;
}
endsnippet

snippet constructord
${1:Name}(${2:${VISUAL/(.+?)(_)(.+?);(\s*)/$1$3(?4:, :)/g}});
endsnippet

snippet constructor
$1::${1:Name}(${2:${VISUAL/(.+?)(_)(.+?);(\s*)/$1$3(?4:, :)/g}})${2/.+/(?0:
	\: :)/}${2/([^,]+\s+[&*]*)(\w+)\s*(,?)/_$2($2)(?3:,
	:)/g}
{
	$0
}
endsnippet

# FUNCTIONS {{{1

snippet fund
${2:const ${3:T}&} ${1:name}($4);
endsnippet

snippet fun
${2:const ${3:T}&} ${1:name}($4)
{
	$0
}
endsnippet

snippet funm
${3:const ${4:T}&} ${1:ClassName}::${2:name}($5)
{
	$0
}
endsnippet

# STD {{{1

snippet cout
std::cout << $0 << std::endl;
endsnippet

snippet cin
std::cin >> $0;
endsnippet

snippet stdarray
std::array<${1:T}, ${2:N}> ${3:name};
endsnippet

snippet stdvector
std::vector<${1:T}> ${2:name};
endsnippet

snippet stdlist
std::list<${1:T}> ${2:name};
endsnippet

snippet stdstack
std::stack<${1:T}> ${2:name};
endsnippet

snippet stdqueue
std::queue<${1:T}> ${2:name};
endsnippet

snippet stdset
std::set<${1:T}> ${2:name};
endsnippet

snippet stdmap
std::map<${1:Key}, ${2:T}> ${3:name};
endsnippet

snippet stduset
std::unordered_set<${1:T}> ${2:name};
endsnippet

snippet stdumap
std::unordered_map<${1:Key}, ${2:T}> ${3:name};
endsnippet
